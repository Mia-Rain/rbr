#!/bin/sh
. ${RPATH:-.}/rbase # pull in the base values
. ${RPATH:-.}/env
. ${RPATH:-.}/gen.env

# some example code for producing an empty screen
# for i in $(seq $LINES); do
#   for i in $(seq $COLUMNS); do
#     print ' '
#   done; echo
# done

s() { # s acts as seq replacement
  n=$(($1)); while [ "$n" -le $(($2)) ]; do
    echo "$n"; : $((n+=1))
  done
}
listgen(){ # generate typelist
  unset typelist
  # gen.env now handles max counter's

  # how many times they /SHOULD/ appear in the list
  ndoor=0;nwall=0;ntopwall=0;ncorner=0;nblank=0 # set all counters to 0
  IFS=";"; tln=0; for i in ${types}; do # produce a number stating how many should be in the list
    : $((tln+=$(printf 'mn%s' "$i")))
  done
  unset IFS
  for i in $(s 1 ${tln}); do
    ran=6;
    unset IFS
    until [ "$ran" -le $(listSz "${types}" ';') -a "$ran" -gt 0 ]; do
      ran=$(${RPATH:-.}/rng/ran)
      until [ "${#ran}" -eq 1 ]; do
        ran="${ran%?}"
      done
    done
    IFS=";"; set -- ${types}; unset IFS
    eval $(printf 'rann=$%s' "$ran")
    case "$rann" in
      blank)
        typelist="${typelist+$typelist;}blank"
        : $((nblank+=1))
        [ $nblank -eq $mnblank ] && types=$(listr "blank" "${types}" ";")
        ;; # blank
      corner)
        typelist="${typelist+$typelist;}corner"
        : $((ncorner+=1))
        [ $ncorner -eq $mncorner ] && types=$(listr "corner" "${types}" ";")
        ;; # corner
      topwall)
        typelist="${typelist+$typelist;}topwall"
        : $((ntopwall+=1))
        [ $ntopwall -eq $mntopwall ] && types=$(listr "topwall" "${types}" ";")
        ;; # topwall
      wall)
        typelist="${typelist+$typelist;}wall"
        : $((nwall+=1))
        [ $nwall -eq $mnwall ] && types=$(listr "wall" "${types}" ";")
        ;; # wall
      door)
        typelist="${typelist+$typelist;}door"
        : $((ndoor+=1))
        [ $ndoor -eq $mndoor ] && types=$(listr "door" "${types}" ";")
        ;; # door
    esac # this is simply faster than a loop
  done
  printf 'new typelist: %s\n' "$typelist" >> ./debug
  unset IFS
}
clist() { # correct errors in typelist
  IFS=";"; unset typelist
  [ ! "${#1}" -gt 1 ] && {
    echo 'EMPTY TYPELIST !?'
    printf 'pos: %s | original typelist: %s\n' "$pos" "$otypelist" >> ./debug
    exit 10
  }
  for i in ${1}; do
    [ "${#i}" -gt 1 ] && {
      typelist="${typelist+${typelist};}$i"
    }
  done
}
sgrid() { # print $1
  case "$1" in
    '=') topwallc=$((${topwallc:-0}+1)) ;;
    '+') unset topwallc
  esac # counter logic
  printf '%s' "$1" >> ./debug
  eval $(printf 'l%sc%s="%s"' "$3" "$2" "$1")
  eval $(printf 'printf $l%sc%s' "$3" "$2")
}
# L = lines; C = COLUMNS
listr() { # create a new typelist using the items in $2; MUST not contain $1
  IFS=${3}
  n=0; for i in ${2}; do
    : $((n+=1))
    [ "$i" != "$1" ] && {
      o="${o+$o$3}$i"
    }
  done
  unset IFS # IFS should be set before calling
  # unset to prevent later issues
  echo "$o"
} # remove an item from $2
listS(){ # return a number that determines the legth of the number of items
  IFS="${2:-;}"
  n=0; for i in ${1:-${typelist}}; do
    : $((n+=1))
  done
  unset IFS
  echo "${#n}"
}
listSz(){ # list ($1) size; uses $2 as IFS or unset
  [ "$2" ] && {
    IFS="$2"
  } || unset IFS
  n=0; for i in ${1}; do
    : $((n+=1))
  done
  echo "$n"
  unset IFS
}
# if there are 4 items in $1/$typelist this will return `1`
pos() { # $1 l $2 c
  oIFS="${IFS}"; IFS=""
  if [ "$1" -eq 1 ]; then
    A=--
  else
    [ "$(eval $(printf 'printf $l%sc%s' "$(($1-1))" "$2") 2>/dev/null)" = " " ] && {
      A="b"
    } || A="$(eval $(printf 'printf $l%sc%s' "$(($1-1))" "$2") 2>/dev/null)$A"
    if [ "$1" -eq 2 ]; then
      A="${A}-"
    else 
      [ "$(eval $(printf 'printf $l%sc%s' "$(($1-2))" "$2") 2>/dev/null)" = " " ] && {
        A="${A}b"
      } || A="$A$(eval $(printf 'printf $l%sc%s' "$(($1-2))" "$2") 2>/dev/null)"
    fi
  fi
  if [ "$2" -eq 1 ]; then
    L=-- # - is placeholder
  else
    [ "$(eval $(printf 'printf $l%sc%s' "$1" "$(($2-1))") 2>/dev/null)" = " " ] && {
      L="b" # replace ' ' (blank) with b
    } || L="$(eval $(printf 'printf $l%sc%s' "$1" "$(($2-1))") 2>/dev/null)"
    if [ "$2" -eq 2 ]; then
      L="-${L}"
    else 
      [ "$(eval $(printf 'printf $l%sc%s' "$1" "$(($2-2))") 2>/dev/null)" = " " ] && {
        L="b$L"
      } || L="$(eval $(printf 'printf $l%sc%s' "$1" "$(($2-2))") 2>/dev/null)$L"
    fi
  fi
  echo "$L $A"; IFS="${oIFS}"
} # output 2 values; leftleft aboveabove # not possible for right or below to be set
dpos() { # diagonal pos # $1 l $2 c
  oIFS="${IFS}"; IFS=""
  if [ "$1" -eq 1 ]; then
    R=-; L=-
  else
    [ "$(eval $(printf 'printf $l%sc%s' "$(($1-1))" "$(($2+1))") 2>/dev/null)" = " " ] && {
      R=b
    } || {
      R="$(eval $(printf 'printf $l%sc%s' "$(($1-1))" "$(($2+1))") 2>/dev/null)"
    }
    [ "$(eval $(printf 'printf $l%sc%s' "$(($1-1))" "$(($2-1))") 2>/dev/null)" = " " ] && {
      L=b
    } || {
      L="$(eval $(printf 'printf $l%sc%s' "$(($1-1))" "$(($2-1))") 2>/dev/null)"
    }
  fi
  echo "$L $R"; IFS="${oIFS}"
} # output 2 values; RightCorner LeftCorner
inchance() { # increase the chance of $1 being picked $2 times # $3 should be `;` or IFS
  oIFS="${IFS}"; unset IFS
  for i in $(s 1 ${2:-1}); do
    [ "$(($(${RPATH:-.}/rng/ran)%2))" -eq 0 ] && {
      typelist="${1+$1${3:-;}}${typelist}"
    } || { 
      typelist="${typelist+${typelist}${3:-;}}$1"
    } 
  done
  IFS="${oIFS}"
}

[ "$LINES" -a "$COLUMNS" ] || exit 10 # exit code 10 will be for rgrid errors
unset IFS otypelist
:>./debug # write `true` to debug (empty)
ml=0; for l in $(s 1 $((LINES-2))); do # for each line
  mc=0; for c in $(s 1 $COLUMNS); do # left to right across screen
    [ "$otypelist" ] && { 
      typelist="$otypelist"
    } || {
      listgen; otypelist="$typelist"
    }
    # generate the typelist
    # basically the idea here is have a list of all possible things a 1x1 space can be
    # wall,door,blank,etc; these are ofc effected by the blocks around them and the current pos
    # basically use ran() and some pain to have it pick what a block should be
    # the list should be dynamic based on the pos and blocks around it
    # ie; placing a door when there is no where for it to lead makes no sense
    if [ "$l1c1" ]; then # counter logic is handled in sgrid() as items are handed off to it after being picked
      # do logic if indexes are set
      pos="$(pos $l $c)"
      case "${pos}" in # ? is any /single/ char
        ?"| "??)
          typelist=$(listr "corner" "${typelist}" ";")
          typelist=$(listr "topwall" "${typelist}" ";") ;;
        "b+ "??)
          typelist=$(listr "corner" "${typelist}" ";")
          typelist=$(listr "blank" "${typelist}" ";") ;;
        ?"b "??)
          typelist=$(listr "topwall" "${typelist}" ";")
          [ "$c" -eq $((COLUMNS -1)) ] && { 
            typelist=$(listr "corner" "${typelist}" ";")
          } || : ;;
        "=+ "??)
          inchance "blank" "3" ";"
          typelist=$(listr "door" "${typelist}" ";")
          typelist=$(listr "corner" "${typelist}" ";")
          typelist=$(listr "wall" "${typelist}" ";") ;;
        ?"+ "??)
          typelist=$(listr "blank" "${typelist}" ";")
          typelist=$(listr "door" "${typelist}" ";")
          typelist=$(listr "corner" "${typelist}" ";")
          typelist=$(listr "wall" "${typelist}" ";") 
          [ "$c" -eq $COLUMNS ] && {
            typelist=$(listr "topwall" "${typelist}" ";")
          } || : ;;
        # corner logic
        ?"= "??)
          typelist=$(listr "door" "${typelist}" ";")
          typelist=$(listr "blank" "${typelist}" ";")
          [ "$topwallc" -a "${topwallc:-0}" -gt "$MC" ] && { # $MC is max columns (length) -- see rbase
            unset topwallc
            typelist="$otypelist" # reset typelist
            typelist=$(listr "topwall" "${typelist}" ";")
            typelist=$(listr "blank" "${typelist}" ";")
          } || {
            [ "$topwallc" -lt 6 ] 2>/dev/null && {
              typelist=$(listr "corner" "${typelist}" ";")
            }
          }
          inchance "topwall" "3" ";"
          [ "$c" -eq $((COLUMNS -1)) ] && {
            inchance "corner" "2" ";"
            typelist=$(listr "topwall" "${typelist}" ";")
          } || :
          ;; # increase the chance of topwall
        # topwall logic
        ?"# "??)
          typelist=$(listr "corner" "${typelist}" ";") 
          typelist=$(listr "topwall" "${typelist}" ";")
          typelist=$(listr "wall" "${typelist}" ";") ;;
        ?"- "??)
          typelist=$(listr "topwall" "${typelist}" ";")
      esac
      # one case for beside, one for above
      case "$pos" in
        ??" #"?)
          inchance "corner" "2" ";"
          typelist=$(listr "blank" "${typelist}" ";")
          typelist=$(listr "topwall" "${typelist}" ";") ;;
        *' |'*)
          inchance "corner" "2" ";"
          inchance "wall" "4" ";"
          typelist=$(listr "topwall" "${typelist}" ";")
          typelist=$(listr "door" "${typelist}" ";")
          typelist=$(listr "blank" "${typelist}" ";") ;;
        ??" bb")
          typelist=$(listr "door" "${typelist}" ";")
          typelist=$(listr "wall" "${typelist}" ";") ;;
        ??" ="?|??" b=")
          typelist=$(listr "topwall" "${typelist}" ";")
          typelist=$(listr "wall" "${typelist}" ";")
          typelist=$(listr "corner" "${typelist}" ";")
          typelist=$(listr "door" "${typelist}" ";") 
          inchance "blank" "4" ";" ;;
        ??" b"?)
          typelist=$(listr "door" "${typelist}" ";")
          #typelist=$(listr "topwall" "${typelist}" ";")
          #typelist=$(listr "corner" "${typelist}" ";")
          typelist=$(listr "wall" "${typelist}" ";") ;;
        ??" +-"|??" +b")
          inchance "wall" "1" ";"
          typelist=$(listr "topwall" "${typelist}" ";")
          typelist=$(listr "corner" "${typelist}" ";")
          typelist=$(listr "blank" "${typelist}" ";") ;;
        ??" +"?)
          typelist=$(listr "topwall" "${typelist}" ";")
          typelist=$(listr "corner" "${typelist}" ";") ;;
        ??" ="?|??" b=")
          typelist=$(listr "topwall" "${typelist}" ";")
          typelist=$(listr "wall" "${typelist}" ";")
          typelist=$(listr "corner" "${typelist}" ";")
          typelist=$(listr "door" "${typelist}" ";") ;;
        ??" -"?)
          typelist=$(listr "wall" "${typelist}" ";")
      esac
      case "$pos" in
        ?'= #'?|?'= |'?)
          typelist=$(listr "wall" "${typelist}" ";")
          inchance "corner" "2" ";"
      esac
    else # below may run if last exit code is !0 and not handled
      typelist=$(listr "door" "${typelist}" ";")
      typelist=$(listr "topwall" "${typelist}" ";")
      typelist=$(listr "wall" "${typelist}" ";")
    fi
    [ "$c" -le 3 -o "$l" -lt 2 ] && { # must be at least 3 over on C to create a door
      # must also be at least 1 L down; this should also be effected by the surrounding blocks
      typelist=$(listr "door" "${typelist}" ";")
    }
  
    clist "${typelist}" # correct any errors in the list
    # $tln is not globally adjusted by listr -- since it runs in a subshell; below is the simplest fix
    IFS=";"; set -- ${typelist}; tln=${#}; unset IFS ran
    printf 'list length: %s | pos: %s - typelist: %s' "$tln${topwallc+ - topwall counter: $topwallc}" "$pos" "$typelist" >> ./debug
    ran=0; until [ "$ran" -gt 0 -a "$ran" -eq "$ran" -a "$ran" -le "$tln" ]; do
      ran=$(${RPATH:-.}/rng/ran) 
      until [ "${ran%0}" = "$ran" ]; do
        ran=${ran%0} 
      done # make sure the last digit is NOT a 0
      until [ "${#ran}" -le $(listS) ]; do
        ran=${ran#?};
        until [ "${ran#0}" = "${ran}" ]; do
          ran="${ran#0}"
        done
      done # shorten $ran until it is the length of the number of items in $typelist
    done
    # generate random number less than or equal to the number of items in $typelist
    IFS=";"
    printf ' | picked: #%s (' "$ran" >> ./debug
    n=0; for i in ${typelist}; do
      : $((n+=1))
      [ "$n" -eq "$ran" ] && {
        [ "$i" = "topwall" -o "$i" = "corner" ] && {
          : $((mc+=1))
        } || mc=0
        eval $(printf 'sgrid "$%s" %s %s' "$i" "$c" "$l")
        # sgrid here is not called within a subshell
        break
      }
    done; unset IFS # now select the item and print it
    printf ')\n' >> ./debug
  done
  echo; unset topwallc # reset counter on now line
  echo 'NEW LINEW' >> ./debug
  # increment a count for $ML and $MC somewhere
done # this prob makes mparse/rparse obsolete lmao
printf '+'; for i in $(s 1 $((COLUMNS-2))); do
  printf '='
done; printf '+\n'

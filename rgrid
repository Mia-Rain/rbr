#!/bin/sh
FILE="$1"
. ${RPATH:-.}/rbase # pull in the base values
. ${RPATH:-.}/env
. ${RPATH:-.}/gen.env

# some example code for producing an empty screen
# for i in $(seq $LINES); do
#   for i in $(seq $COLUMNS); do
#     print ' '
#   done; echo
# done

s() { # s acts as seq replacement
  n=$(($1)); while [ "$n" -le $(($2)) ]; do
    echo "$n"; : $((n+=1))
  done
}
listgen(){ # generate typelist
  unset typelist
  # gen.env now handles max counter's

  # how many times they /SHOULD/ appear in the list
  ndoor=0;nwall=0;ntopwall=0;ncorner=0;nblank=0;nfloor=0 # set all counters to 0
  IFS=";"; tln=0; for i in ${types}; do # produce a number stating how many should be in the list
    : $((tln+=$(printf 'mn%s' "$i")))
  done
  unset IFS
  for i in $(s 1 ${tln}); do
    ran=6;
    unset IFS
    until [ "$ran" -le $(listSz "${types}" ';') -a "$ran" -gt 0 ]; do
      ran=$(${RPATH:-.}/rng/ran)
      until [ "${#ran}" -eq 1 ]; do
        ran="${ran%?}"
      done
    done
    IFS=";"; set -- ${types}; unset IFS
    eval $(printf 'rann=$%s' "$ran")
    case "$rann" in
      floor)
        typelist="${typelist+$typelist;}floor"
        : $((nfloor+=1))
        [ $nfloor -eq $mnfloor ] && types=$(listr "floor" "${types}" ";")
        ;;
      blank)
        typelist="${typelist+$typelist;}blank"
        : $((nblank+=1))
        [ $nblank -eq $mnblank ] && types=$(listr "blank" "${types}" ";")
        ;; # blank
      corner)
        typelist="${typelist+$typelist;}corner"
        : $((ncorner+=1))
        [ $ncorner -eq $mncorner ] && types=$(listr "corner" "${types}" ";")
        ;; # corner
      topwall)
        typelist="${typelist+$typelist;}topwall"
        : $((ntopwall+=1))
        [ $ntopwall -eq $mntopwall ] && types=$(listr "topwall" "${types}" ";")
        ;; # topwall
      wall)
        typelist="${typelist+$typelist;}wall"
        : $((nwall+=1))
        [ $nwall -eq $mnwall ] && types=$(listr "wall" "${types}" ";")
        ;; # wall
      door)
        typelist="${typelist+$typelist;}door"
        : $((ndoor+=1))
        [ $ndoor -eq $mndoor ] && types=$(listr "door" "${types}" ";")
        ;; # door
    esac # this is simply faster than a loop
  done
  printf 'new typelist: %s\n' "$typelist" >> ./debug
  unset IFS
}

clist() { # correct errors in typelist
  IFS=";"; unset typelist
  # dash correction -- dash seems to have issues with the positional logic after l1 (l3)
  # after setting 3 columns typelist seems to reset and ignore the cases all together
  # something is likely calling sgrid before it should be
  sidepos; apos; diapos

  [ ! "${#1}" -gt 1 ] && {
    printf 'empty typelist!!! -- ' >> ./debug
    case "$vpos" in
     ?"b +"?) inchance "blank" "2" ";" ;;
     ?"= "??) typelist=$(listr "blank" "${typelist}" ";") ;;
     ?"= +") inchance "corner" "3" ";" ;; # end walls in corners
     *)
      printf 'COULD NOT CORRECT...\n' >> ./debug
      printf 'pos: %s | original typelist: %s\n' "$vpos & $vdpos" "$otypelist" >> ./debug
      exit 12
    esac
    printf 'corrected...\n' >> ./debug
  }
  case "$vpos" in
    ?'= '??|?'+ '??) : ;;
    ??' '?) inchance "floor" "3" ";"
  esac
  for i in ${1}; do
    [ "${#i}" -gt 1 ] && {
      typelist="${typelist+${typelist};}$i"
    }
  done # this corrects... something ... (?) ... /NEEDED/ for l1c1 (l3c3)

  # typelist can contain a ';;' -- idk why this happens but this corrects it as it can cause `$` to be "chosen"
  IFS=""; p="${typelist}"; unset typelist
  n=0; while [ "$p" ]; do
    next="${p#?}" # current is ${p%$next}
    [ "${p%$next}" = ";" -a "${next%${next#?}}" = ";" -o "$n" -eq 0 -a "${p%$next}" = ";" ] && { 
      echo 'typelist error!!! -- correcting...' >> ./debug
    } || typelist="${typelist}${p%$next}"
    p="${next}"; unset next
    : $((n+=1))
  done; unset n
}
sgrid() { # print $1 # $3 l $2 c
  case "$1" in
    '=') topwallc=$((${topwallc:-0}+1)) ;;
    '#'|'|') wallc=$((${wallc:-0}+1)); ;;    
    '+') unset topwallc; unset wallc ;;
    ' ') unset room 
  esac # counter logic
  # DEBUG
  printf 'list length: %s | pos: %s | l %s c %s | room: %s ' "$tln" "$vpos & $vdpos" "$l" "$c" "${room:-false}" >> ./debug
  case "$1" in
    '=') printf '| topwall counter: %s ' "${topwallc:-0}" >> ./debug  ;;
    '#'|'|') printf '| wall counter: %s ' "${wallc:-0}" >> ./debug
  esac
  printf '| typelist: %s | picked #%s (' "$typelist" "$ran" >> ./debug 
  printf '%s)\n' "$1" >> ./debug; [ "$FILE" ] || printf '%s' "$1" >> state
  eval $(printf 'l%sc%s="%s"' "$3" "$2" "$1")
  eval $(printf 'printf $l%sc%s' "$3" "$2")
}
# L = lines; C = COLUMNS
listr() { # create a new typelist using the items in $2; MUST not contain $1
  oIFS="${IFS}" IFS=";"
  ctypelist="${2}"
  [ "${#2}" -gt 1 ] || {
    printf '\n'
    exit 13 # list error
  }
  n=0; for i in ${2}; do
    : $((n+=1))
    [ "$i" != "$1" ] && {
      o="${o+${o};}$i"
    }
  done
  [ "$l" -gt 3 -a "$ctypelist" = "$o" ] && {
    printf 'listr failed to change typelist...\n' >> ./debug
    exit 13
  }
  IFS="${oIFS}" # IFS should be set before calling
  # unset to prevent later issues
  echo "$o"
} # remove an item from $2
listS(){ # return a number that determines the legth of the number of items
  IFS="${2:-;}"
  n=0; for i in ${1:-${typelist}}; do
    : $((n+=1))
  done
  unset IFS
  echo "${#n}"
}
listSz(){ # list ($1) size; uses $2 as IFS or unset
  [ "$2" ] && {
    IFS="$2"
  } || unset IFS
  n=0; for i in ${1}; do
    : $((n+=1))
  done
  echo "$n"
  unset IFS
}
# if there are 4 items in $1/$typelist this will return `1`
pos() { # $1 l $2 c
  oIFS="${IFS}"; IFS=""
  if [ "$1" -eq 3 ]; then
    A=--
  else
    [ "$(eval $(printf 'printf $l%sc%s' "$(($1-1))" "$2") 2>/dev/null)" = " " ] && {
      A="b"
    } || A="$(eval $(printf 'printf $l%sc%s' "$(($1-1))" "$2") 2>/dev/null)$A"
    if [ "$1" -eq 4 ]; then
      A="${A}-"
    else 
      [ "$(eval $(printf 'printf $l%sc%s' "$(($1-2))" "$2") 2>/dev/null)" = " " ] && {
        A="${A}b"
      } || A="$A$(eval $(printf 'printf $l%sc%s' "$(($1-2))" "$2") 2>/dev/null)"
    fi
  fi
  if [ "$2" -eq 3 ]; then
    L=-- # - is placeholder
  else
    [ "$(eval $(printf 'printf $l%sc%s' "$1" "$(($2-1))") 2>/dev/null)" = " " ] && {
      L="b" # replace ' ' (blank) with b
    } || L="$(eval $(printf 'printf $l%sc%s' "$1" "$(($2-1))") 2>/dev/null)"
    if [ "$2" -eq 4 ]; then
      L="-${L}"
    else 
      [ "$(eval $(printf 'printf $l%sc%s' "$1" "$(($2-2))") 2>/dev/null)" = " " ] && {
        L="b$L"
      } || L="$(eval $(printf 'printf $l%sc%s' "$1" "$(($2-2))") 2>/dev/null)$L"
    fi
  fi
  echo "$L $A"; IFS="${oIFS}"
} # output 2 values; leftleft aboveabove # not possible for right or below to be set
dpos() { # diagonal pos # $1 l $2 c
  oIFS="${IFS}"; IFS=""
  if [ "$1" -le 3 ]; then
    R=-; L=-
  else
    [ "$(eval $(printf 'printf $l%sc%s' "$(($1-1))" "$(($2+1))") 2>/dev/null)" = " " ] && {
      R=b
    } || {
      R="$(eval $(printf 'printf $l%sc%s' "$(($1-1))" "$(($2+1))") 2>/dev/null)"
    }
    [ "$(eval $(printf 'printf $l%sc%s' "$(($1-1))" "$(($2-1))") 2>/dev/null)" = " " ] && {
      L=b
    } || {
      L="$(eval $(printf 'printf $l%sc%s' "$(($1-1))" "$(($2-1))") 2>/dev/null)"
    }
  fi
  [ "$2" -le 3 ] && L=-
  echo "$L $R"; IFS="${oIFS}"
} # output 2 values; RightCorner LeftCorner
inchance() { # increase the chance of $1 being picked $2 times # $3 should be `;` or IFS
  oIFS="${IFS}"; unset IFS
  for i in $(s 1 ${2:-1}); do
    [ "$(($(${RPATH:-.}/rng/ran)%2))" -eq 0 ] && {
      typelist="${1+$1${3:-;}}${typelist}"
    } || { 
      typelist="${typelist+${typelist}${3:-;}}$1"
    } 
  done
  IFS="${oIFS}"
}

# ALWAYS
[ "$LINES" -a "$COLUMNS" ] || exit 10 # exit code 10 will be for rgrid errors
unset IFS otypelist
# CON
cont() { # continue reading from a state file -- given as $1 or `-` for STDIN
  oIFS="${IFS}"; IFS=""; #l=3
  : $((l-=1))
  while read -r p || [ -n "$p" ]; do
    c=3; vdpos="$(dpos $l $c)"; vpos="$(pos $l $c)"
    : $((l+=1)); [ "$l" -gt 3 ] && {
      echo; c=1
      bord; [ "$bord" ] && {
        printf '%s' "$bord"
        : $((c+=2))
      }
      printf ' '
    } 
    while [ "$p" ]; do
      next="${p#?}" # current is ${p%$next}
      sgrid "${p%$next}" "$c" "$l"
      : $((c+=1))
      p="${next}"; unset next
    done
  done
  export Fc=$c
  unset FILE
  IFS="${oIFS}"
}
bord() {
  case "$l" in
    '1'|"$LINES")
      [ "$c" -eq 1 -o "$c" -eq $COLUMNS ] && {
        bord="$corner"
      } || bord="$topwall" ;;
    '2'|"$((LINES-1))")
      bord="$blank" ;;
    *)
      unset bord
  esac
  case "$c" in
    '1'|$COLUMNS)
      [ "$l" -eq 1 -o "$l" -eq $LINES ] || bord="$wall" ;;
    '2'|"$((COLUMNS-1))")
      [ "$bord" ] || bord="$blank" ;;
    *) 
      [ "$bord" ] || unset bord
  esac
}
# DEFAULT
:>./debug # write `true` to debug (empty)
[ "$1" -a "$FILE" ] && {
  case "${FILE}" in
    'help'|'-h'|'--h'*|'?') 
      while read -r p || [ "$p" ] ; do
        echo "$p"
      done << 'EOF'
rgrid: Generates a "level" layout using a drunkard walk algo
Usage:
  ./rgrid
    -- generate starting from l1c1
  ./rgrid ./state
    -- read from ./state using cont() then resume generation at its end
  ./rgrid help 
    -- prints this silly
EOF
      exit 0;;
  esac
}
# POSITIONAL FUNCTIONS
diapos() {
  case "$vdpos" in
    ?' +'|'+ '?|?' #')
      typelist=$(listr "corner" "${typelist}" ";") ;;
    ??'b'|??' ')
      case "$vpos" in
        ?'b '??)
          typelist=$(listr "door" "${typelist}" ";")
          typelist=$(listr "wall" "${typelist}" ";")
      esac; : ;;
    ??'|')
      typelist=$(listr "corner" "${typelist}" ";")
  esac
}
roompos() {
  case "$vdpos $vpos" in
    ?' '?' '?'= '??|?????'b '??)
      unset room ;;
    '+ '?' '??' ='?|'= '?' '?'b '??|?' '?' '?' ='?|?' '?' '??' '?|?'  '??' b'?|?'  '??' +'?|?'  '??' ='?|?' = '?' '??|?????'| ='?)
      room="true" ;;
    *)
      unset room
  esac
}
sidepos() {
  case "$vpos" in # ? is any /single/ char
    "+ "??)
      typelist=$(listr "floor" "${typelist}" ";") && unset room
      typelist=$(listr "blank" "${typelist}" ";")
      typelist=$(listr "corner" "${typelist}" ";") ;;
    "# "??|"| "??|"+ "??)
      typelist=$(listr "door" "${typelist}" ";")
      typelist=$(listr "wall" "${typelist}" ";")
      typelist=$(listr "topwall" "${typelist}" ";")
      typelist=$(listr "corner" "${typelist}" ";") ;;
    "b| "??)
      inchance "floor" "3" ";"
      typelist=$(listr "corner" "${typelist}" ";")
      typelist=$(listr "topwall" "${typelist}" ";") ;;
    ?"| "??)
      typelist=$(listr "corner" "${typelist}" ";")
      typelist=$(listr "topwall" "${typelist}" ";") ;;
    "+b "??)
      typelist=$(listr "topwall" "${typelist}" ";")
      typelist=$(listr "door" "${typelist}" ";") ;;
    "b+ "??)
      typelist=$(listr "door" "${typelist}" ";")
      typelist=$(listr "corner" "${typelist}" ";")
      typelist=$(listr "blank" "${typelist}" ";") ;;
    ?"b "??|?" "??)
      typelist=$(listr "topwall" "${typelist}" ";") ;;
    "=+ "??)
      inchance "blank" "3" ";"
      typelist=$(listr "door" "${typelist}" ";")
      typelist=$(listr "corner" "${typelist}" ";")
      typelist=$(listr "wall" "${typelist}" ";") ;;
    ?"+ "??)
      typelist=$(listr "blank" "${typelist}" ";")
      typelist=$(listr "door" "${typelist}" ";")
      typelist=$(listr "corner" "${typelist}" ";")
      typelist=$(listr "wall" "${typelist}" ";") 
      [ "$c" -eq $COLUMNS ] && {
        typelist=$(listr "topwall" "${typelist}" ";")
      } || : ;;
      # corner logic
    ?"= "??)
      typelist=$(listr "door" "${typelist}" ";")
      typelist=$(listr "blank" "${typelist}" ";")
      [ "$topwallc" -a "${topwallc:-0}" -gt "$MC" ] && { # $MC is max columns (length) -- see rbase
        typelist=$(listr "topwall" "${typelist}" ";")
        typelist=$(listr "blank" "${typelist}" ";")
      } || {
        [ "$topwallc" -lt $((MiC+1)) ] 2>/dev/null && {
          typelist=$(listr "corner" "${typelist}" ";")
        }
      }
      inchance "topwall" "3" ";" ;; # increase the chance of topwall
    # topwall logic
    "b# "??)
      room="true"; inchance "floor" "3" ";"
      typelist=$(listr "door" "${typelist}" ";")
      typelist=$(listr "blank" "${typelist}" ";")
      typelist=$(listr "corner" "${typelist}" ";")
      typelist=$(listr "topwall" "${typelist}" ";")
      typelist=$(listr "wall" "${typelist}" ";") ;;
    ?"# "??|"#"?" "??)
      typelist=$(listr "door" "${typelist}" ";")
      typelist=$(listr "corner" "${typelist}" ";") 
      typelist=$(listr "topwall" "${typelist}" ";")
      typelist=$(listr "wall" "${typelist}" ";") ;;
    ?"- "??)
      typelist=$(listr "topwall" "${typelist}" ";")
  esac
}
apos() {
  case "$vpos" in
    ??" ++")
      typelist=$(listr "corner" "${typelist}" ";")
      typelist=$(listr "door" "${typelist}" ";")
      typelist=$(listr "wall" "${typelist}" ";") ;;
    ??" #"?)
      [ "${wallc:-0}" -lt $((MiL+1)) ] && {
        typelist=$(listr "corner" "${typelist}" ";")
      } || inchance "corner" "2" ";"
      [ "${wallc:-0}" -gt $ML ] && typelist=$(listr "wall" "${typelist}" ";")
        case "$vpos" in
          ?" #+") typelist=$(listr "corner" "${typelist}" ";")
        esac
        case "$vpos" in
          ?"b "??) : ;;
          *)
            typelist=$(listr "blank" "${typelist}" ";")
        esac
        typelist=$(listr "topwall" "${typelist}" ";") ;;
    ??" |"?)
      inchance "wall" "2" ";"
      [ "${wallc:-0}" -lt $((MiL+1)) ] && {
        typelist=$(listr "corner" "${typelist}" ";")
      }
      [ "${wallc:-0}" -gt $ML ] && typelist=$(listr "wall" "${typelist}" ";")
      typelist=$(listr "topwall" "${typelist}" ";")
      typelist=$(listr "door" "${typelist}" ";")
      case "$vpos" in
        ?'b '??) : ;;
        *) typelist=$(listr "blank" "${typelist}" ";")
      esac ;;
    ??" bb")
      typelist=$(listr "door" "${typelist}" ";")
      typelist=$(listr "wall" "${typelist}" ";") ;;
    ??" ="?|??" "?)
      case "$vpos" in
        ??' '|?'+ '|'+= '|'== '|?'+ +'|'+= +'|'== +') : ;;
        *)
          typelist=$(listr "corner" "${typelist}" ";")
          typelist=$(listr "topwall" "${typelist}" ";")
          inchance "blank" "2" ";"
      esac
      typelist=$(listr "wall" "${typelist}" ";")
      typelist=$(listr "door" "${typelist}" ";") 
      case "$vpos" in
        ??' '?) inchance "floor" "4" ";"
      esac ;;
    ??" b"?)
      typelist=$(listr "door" "${typelist}" ";")
      typelist=$(listr "wall" "${typelist}" ";") ;;
    ??" +-"|??" +b")
      case "$vpos" in
        '#'????|?'# '??|?'| '??) typelist=$(listr "wall" "${typelist}" ";") ;; # cannot be wall if wall is 2 blocks over 
        ?"b "??|?" "??)
          inchance "wall" "2" ";"
      esac
      typelist=$(listr "topwall" "${typelist}" ";")
      typelist=$(listr "corner" "${typelist}" ";")
      typelist=$(listr "blank" "${typelist}" ";") ;;
    ??" +"?)
      case "$vpos" in
        '#'????|?'# '??|?'| '??|'| '??) typelist=$(listr "wall" "${typelist}" ";") ;; # cannot be wall if wall is 2 blocks over 
        ?"b "??|?" "??)
          inchance "wall" "3" ";"
      esac
      typelist=$(listr "topwall" "${typelist}" ";")
      typelist=$(listr "corner" "${typelist}" ";") ;;
    ??" ="?|??" b=")
      typelist=$(listr "topwall" "${typelist}" ";")
      typelist=$(listr "wall" "${typelist}" ";")
      typelist=$(listr "corner" "${typelist}" ";")
      typelist=$(listr "door" "${typelist}" ";") ;;
    ??" -"?)
      typelist=$(listr "door" "${typelist}" ";")
      typelist=$(listr "wall" "${typelist}" ";")
  esac
}
[ "$FILE" ] || :>./state 
ml=0; for l in $(s 1 $LINES); do # for each line
  [ "$l" -gt 3 ] && printf '\n' >> ./state
  mc=0; for c in $(s 1 $COLUMNS); do # left to right across screen
    [ "$Fc" ] && {
      : $((c+=Fc))
      [ "$Fc" -ge 3 ] && : $((c-=3))
    }

    bord; [ "$bord" ] && {
      printf '%s' "$bord"
      continue
    } # draw borders
    [ "$c" -gt $((COLUMNS-6 -2)) ] && {
      vpos="$(pos $l $c)"
      case "$vpos" in
        *'= '*)
          sgrid "$corner" "$c" "$l" ;;
        *)
          printf '%s' "$blank"; printf '%s' "$blank" >> ./state
      esac
      continue
    } # draw right side edge

    typelist=$(listr "floor" "${typelist}" ";")
    [ "$otypelist" ] && { 
      typelist="$otypelist"
    } || {
      listgen; otypelist="$typelist"
      otypelist=$(listr "floor" "${otypelist}" ";")
    }

    [ "$FILE" ] && {
      case "$FILE" in
        '-') cont <&0 ;;
        *) cont < "${FILE}"
      esac
      unset FILE
    }
    
    # generate the typelist
    # basically the idea here is have a list of all possible things a 1x1 space can be
    # wall,door,blank,etc; these are ofc effected by the blocks around them and the current pos
    # basically use ran() and some pain to have it pick what a block should be
    # the list should be dynamic based on the pos and blocks around it
    # ie; placing a door when there is no where for it to lead makes no sense
    if [ "$l3c3" ]; then # counter logic is handled in sgrid() as items are handed off to it after being picked
      printf 'start positional logic...\n' >> ./debug
      # do logic if indexes are set
      vdpos="$(dpos $l $c)"
      vpos="$(pos $l $c)"
      ## POSITIONAL LOGIC
      
      ## ROOM/SMART
      roompos
      ## BESIDE
      sidepos
      # one case for beside, one for above
      ## BELOW/ABOVE
      apos
      case "$vpos" in
        ?'= #'?|?'= |'?|?'= +'?|?'+ #'?|?'+ +'?)
          typelist=$(listr "wall" "${typelist}" ";")
          inchance "corner" "2" ";"
      esac
      ## DIAGONAL
      diapos
      
      ## FLOOR
      [ "$room" ] && {
        case "$vpos" in
          "bb ="|"# =") inchance "blank" "4" ";" ;;
          *)
            typelist=$(listr "blank" "${typelist}" ";")
            inchance "floor" "3" ";"
        esac
      } || typelist=$(listr "floor" "${typelist}" ";")
      [ "$l" -gt 3 ] && { 
        printf 'finished positional logic... checking for errors...\n' >> ./debug
      }

    else # below may run if last exit code is !0 and not handled
      typelist=$(listr "floor" "${typelist}" ";") 
      typelist=$(listr "door" "${typelist}" ";")
      typelist=$(listr "topwall" "${typelist}" ";")
      typelist=$(listr "wall" "${typelist}" ";")
      [ "$l" -gt 3 ] && {
        printf 'failed to preform positional logic... $l3c3 likely unset\n' >> ./debug
      }
    fi
    [ "$c" -le 3 -o "$l" -lt 2 ] && { # must be at least 3 over on C to create a door
      # must also be at least 1 L down; this should also be effected by the surrounding blocks
      typelist=$(listr "door" "${typelist}" ";")
    }
  
    clist "${typelist}" # correct any errors in the list
    # $tln is not globally adjusted by listr -- since it runs in a subshell; below is the simplest fix
    IFS=";"; set -- ${typelist}; tln=${#}; unset IFS ran
    ran=0; until [ "$ran" -gt 0 -a "$ran" -eq "$ran" -a "$ran" -le "$tln" ]; do
      ran=$(${RPATH:-.}/rng/ran) 
      until [ "${ran%0}" = "$ran" ]; do
        ran=${ran%0} 
      done # make sure the last digit is NOT a 0
      until [ "${#ran}" -le $(listS) ]; do
        ran=${ran#?};
        until [ "${ran#0}" = "${ran}" ]; do
          ran="${ran#0}"
        done
      done # shorten $ran until it is the length of the number of items in $typelist
    done
    # generate random number less than or equal to the number of items in $typelist
    IFS=";"
    n=0; for i in ${typelist}; do
      : $((n+=1))
      [ "$n" -eq "$ran" ] && {
        [ "$i" = "topwall" -o "$i" = "corner" ] && {
          : $((mc+=1))
        } || mc=0
        eval $(printf 'sgrid "$%s" %s %s' "$i" "$c" "$l")
        # sgrid here is not called within a subshell
        break
      }
    done; unset IFS # now select the item and print it
  done
  echo; unset topwallc # reset counter on now line
  [ "$bord" ] || echo 'NEW LINE' >> ./debug && unset Fc
  [ "$bord" ] || printf '\n' >> ./state
done # this prob makes mparse/rparse obsolete lmao


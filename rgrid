#!/bin/sh
. ${RPATH:-.}/rbase # pull in the base values
. ${RPATH:-.}/env

# some example code for producing an empty screen
# for i in $(seq $LINES); do
#   for i in $(seq $COLUMNS); do
#     print ' '
#   done; echo
# done

s() { # s acts as seq replacement
  n=$(($1)); while [ "$n" -le $(($2)) ]; do
    echo "$n"; : $((n+=1))
  done
}
listgen(){ # generate typelist
  unset typelist
  types="door;wall;topwall;corner;blank" # these are all the defined types
  mndoor="2"
  mnwall="3"
  mntopwall="3"
  mncorner="4" # corners should be more likely than walls
  mnblank="8" # blank space should be the most likely
  # max counter
  # how many times they /SHOULD/ appear in the list
  ndoor=0;nwall=0;ntopwall=0;ncorner=0;nblank=0 # set all counters to 0

  IFS=";"; tln=0; for i in ${types}; do # produce a number stating how many should be in the list
    : $((tln+=$(printf 'mn%s' "$i")))
  done
  unset IFS
  for i in $(s 1 ${tln}); do
    ran=6;
    unset IFS
    until [ "$ran" -le $(listSz "${types}" ';') -a "$ran" -gt 0 ]; do
      ran=$(${RPATH:-.}/rng/ran)
      until [ "${#ran}" -eq 1 ]; do
        ran="${ran%?}"
      done
    done
    IFS=";"; set -- ${types}; unset IFS
    eval $(printf 'rann=$%s' "$ran")
    case "$rann" in
      blank)
        typeplist="${typelist+typelist;}blank"
        : $((nblank+=1))
        [ "$nblank" -eq "$mnblank" ] && listr "blank" "${types}" ";"
        ;; # blank
      corner)
        typeplist="${typelist+typelist;}corner"
        : $((ncorner+=1))
        [ "$ncorner" -eq "$mncorner" ] && listr "corner" "${types}" ";"
        ;; # corner
      topwall)
        typeplist="${typelist+typelist;}topwall"
        : $((ntopwall+=1))
        [ "$ntopwall" -eq "$mntopwall" ] && listr "topwall" "${types}" ";"
        ;; # topwall
      wall)
        typeplist="${typelist+typelist;}wall"
        : $((nwall+=1))
        [ "$nwall" -eq "$mnwall" ] && listr "wall" "${types}" ";"
        ;; # wall
      door)
        typeplist="${typelist+typelist;}door"
        : $((ndor+=1))
        [ "$ndoor" -eq "$mndoor" ] && listr "door" "${types}" ";"
        ;; # door
    esac # this is simply faster than a loop
  done
  unset IFS
}
sgrid() { # print $1
  #printf '%s' "$1"
  eval $(printf 'l%sc%s="%s"' "$3" "$2" "$1")
  eval $(printf 'printf $l%sc%s' "$3" "$2")
}
# L = lines; C = COLUMNS
listr() { # create a new typelist using the items in $2; MUST not contain $1
  unset typelist
  n=0; for i in ${2}; do
    : $((n+=1))
    [ "$i" != "$1" ] && {
      typelist="${typelist+$typelist$3}$i"
    }
  done
  tln=$((n-1))
  unset IFS # IFS should be set before calling
  # unset to prevent later issues
} # remove an item from typelist

listS(){ # return a number that determines the legth of the number of items
  IFS="${2:-;}"
  n=0; for i in ${1:-${typelist}}; do
    : $((n+=1))
  done
  unset IFS
  echo "${#n}"
}
listSz(){ # list ($1) size; uses $2 as IFS or unset
  [ "$2" ] && {
    IFS="$2"
  } || unset IFS
  n=0; for i in ${1}; do
    : $((n+=1))
  done
  echo "$n"
  unset IFS
}
# if there are 4 items in $1/$typelist this will return `1`
pos() { # $1 l $2 c
  [ "$1" -eq 1 ] && {
    A=-
  } || A="$(eval $(printf 'printf $l%sc%s' "$(($1-1))" "$2") 2>/dev/null)"
  [ "$2" -eq 1 ] && {
    L=- # - is placeholder
  } || L="$(eval $(printf 'printf $l%sc%s' "$1" "$(($2-1))") 2>/dev/null)"
  echo "$L $A"
} # output 2 values; left above # not possible for right or below to be set

[ "$LINES" -a "$COLUMNS" ] || exit 10 # exit code 10 will be for rgrid errors
unset IFS
ml=0; for l in $(s 1 $LINES); do # for each line
  mc=0; for c in $(s 1 $COLUMNS); do # left to right across screen
    [ "$otypelist" ] && { 
      typelist="$otypelist"
    } || {
      listgen; otypelist="$typelist"
    }
    # generate the typelist
    # basically the idea here is have a list of all possible things a 1x1 space can be
    # wall,door,blank,etc; these are ofc effected by the blocks around them and the current pos
    # basically use ran() and some pain to have it pick what a block should be
    # the list should be dynamic based on the pos and blocks around it
    # ie; placing a door when there is no where for it to lead makes no sense
    [ "$l" -eq 1 ] && {                     
      ls=0                                         
    } || ls=1                          
    [ "$c" -eq 1 ] && {             
      cs=0                                                                           
    } || cs=1                                                                        
    [ "$(eval $(printf 'printf $l%sc%s' "$((l-ls))" "$((c-cs))") 2>/dev/null)" ] && {
      # do logic if indexes are set
      : 
    } || {
      IFS=";"
      listr "door" "${typelist}" ";"
      IFS=";"
      listr "topwall" "${typelist}" ";"
      IFS=";"
      listr "wall" "${typelist}" ";"
    }
    
    [ "$c" -le 3 -o "$l" -lt 2 ] && { # must be at least 3 over on C to create a door
      # must also be at least 1 L down; this should also be effected by the surrounding blocks
      IFS=';'
      listr "door" "${typelist}" ";"
    }

    #[ "$mc" -eq "$MC" ] && {
    #  listr "topwall" "${typelist}" ";"
    #}

    # now use ran to generate a random number
    # $((ran*ran))
    ran=0; until [ "$ran" -gt 0 -a "$ran" -eq "$ran" -a "$ran" -le "$((tln+1))" ]; do
      #ran=$(( $(${RPATH:-.}/rng/ran)*$(${RPATH:-.}/rng/ran) ))
      ran=$(${RPATH:-.}/rng/ran)
      until [ "${#ran}" -le $(listS) ]; do
        ran=${ran%?}
      done # shorten $ran until it is the length of the number of items in $typelist
    done
    #echo "$tln | $ran"
    IFS=";"
    n=0; for i in ${typelist}; do
      : $((n+=1))
      [ "$n" -eq "$ran" ] && {
        [ "$i" = "topwall" -o "$i" = "corner" ] && {
          : $((mc+=1))
        } || mc=0
        eval $(printf 'sgrid "$%s" %s %s' "$i" "$c" "$l")
        break
      }
    done; unset IFS # now select the item and print it
  done
  echo
  # increment a count for $ML and $MC somewhere
done # this prob makes mparse/rparse obsolete lmao
